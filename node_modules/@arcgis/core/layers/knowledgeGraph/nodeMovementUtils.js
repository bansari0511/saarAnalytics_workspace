/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import{makeHandle as t}from"../../core/handleUtils.js";import{getOrCreateMapValue as r}from"../../core/MapUtils.js";import{floatEqualRelative as a}from"../../core/mathUtils.js";import o from"../../geometry/Point.js";import i from"../../geometry/Polyline.js";import{initializeProjection as s,project as n}from"../../geometry/projectionUtils.js";import c from"../GraphicsLayer.js";import{convertToGeometry as p}from"../graphics/featureConversionUtils.js";import{kgRestServices as h}from"../../rest/knowledgeGraphService.js";import d from"../../rest/knowledgeGraph/GraphQueryStreaming.js";import u from"../../rest/knowledgeGraph/KnowledgeGraph.js";import l from"../../views/draw/support/Reshape.js";import{loadAutomaticAreaMeasurementUtils as m}from"../../views/support/automaticAreaMeasurementUtils.js";import{loadAutomaticLengthMeasurementUtils as g}from"../../views/support/automaticLengthMeasurementUtils.js";const y={newReshapeWrapper:async({getFeatureReshapeProvider:e,targetGraphic:t,reshapeGraphicsLayer:r,view:a,snappingManager:o})=>new l({automaticAreaMeasurementUtils:await m(),automaticLengthMeasurementUtils:await g(),connectedReshapeProviders:[{getFeatureReshapeProvider:e,getVertexReshapeProvider(){throw new Error("Link Charts do not support vertex (polyline) reshape at this time")}}],enableMidpoints:!1,graphic:t,layer:r,view:a,snappingManager:o})},f=async({targetEntityId:r,targetEntityType:i,view:h,snappingManager:d})=>{await s({wkid:4326},h.spatialReference);const u=h.map?.activeLinkChartLayer?.layers.find((e=>e.objectType.name===i));if(!u)throw new e("LinkChartView:target-layer-not-found",`No layer found for target entity type ${i}`);const l=u.createQuery();l.objectIds=[r];const m=await u.queryFeatures(l);if(0===m.features.length)throw new e("LinkChartView:no-matching-feature-found",`No feature found with ID ${r} in layer ${u.title}`);const g=m.features[0].clone(),f=g.attributes.ESRI__ID;if(!g.sourceLayer)throw new e("LinkChartView:no-source-layer",`The target graphic does not have a source layer: ${f}`);const L=new c({listMode:"hide",internal:!0});g.geometry=n(new o(p(g.attributes.ESRI__LayoutGeometry,"esriGeometryPoint",!1,!1)),h.spatialReference),h.map.add(L),L.add(g);const v=g.sourceLayer,j=v.parent,M=new Map([[f,[]]]),C=new Map,b=new Map,R=await w(r,u,h),_=new Map;for(const e of j.layers)_.set(e.objectType.name,e);const x=new Map;for(const[e,t]of j.sublayerIdsCache)j.dataManager.relationshipTypeNames.has(e)&&x.set(e,Array.from(t));const D=await I(f,v.objectType.name,j.knowledgeGraph,x),E=j.entityLinkChartDiagramLookup.get(f);for(const e of D){let t=C.get(e.id);if(t||(t=j.relationshipLinkChartDiagramLookup.get(e.id),C.set(e.id,t??null)),t){const r=_.get(e.typeName);r&&a(t.coords[0],E.coords[0])&&a(t.coords[1],E.coords[1])?M.get(f)?.push({objectId:e.id,pathIndex:0,vertexIndex:0,associatedSublayer:r}):r&&a(t.coords.at(-2),E.coords[0])&&a(t.coords.at(-1),E.coords[1])&&M.get(f)?.push({objectId:e.id,pathIndex:0,vertexIndex:t.coords.length/2-1,associatedSublayer:r})}}const F=e=>new k(e,b,M,h),G=await y.newReshapeWrapper({getFeatureReshapeProvider:F,targetGraphic:g,reshapeGraphicsLayer:L,view:h,snappingManager:d});G.on("move-stop",(e=>{h.emit("node-movement-stop",e)}));const T=t((()=>{R.remove(),L.removeAll(),h.map.remove(L),L.destroy(),b.clear(),C.clear(),G.destroy()}));return{currentReshapeGraphic:G.graphic,localEdits:b,originalRelationshipGeometries:C,teardownHandle:T}},w=async(e,t,r)=>{const a=await r.whenLayerView(t);return a.setVisibility(e,!1),{remove:()=>a.setVisibility(e,!0)}},I=async(e,t,r,a,o)=>{const i={sourceId:e},s=[],n=[];for(const[h,d]of a){const e=`${h}_ids`;i[e]=d,n.push(`Match (n:${t}) WHERE id(n) = $sourceId WITH n MATCH (n)-[r:${h}]-() WHERE ID(r) IN $${e} RETURN {id: ID(r), typeName: type(r)} as result`)}const c=n.join(" UNION "),p=(await h.executeQueryStreaming(new u(JSON.parse(JSON.stringify(r))),new d({openCypherQuery:c,bindParameters:i}),o)).resultRowsStream.getReader();for(;;){const{done:e,value:t}=await p.read();if(e)break;t.forEach((e=>{s.push(e[0].properties)}))}return s};class L{constructor(e,t){this.modifiedFeatures=new Map,this.updating=!1,this._totalDx=0,this._totalDy=0,this._localEditsCache=e,this._view=t}async initializeModifiedFeatures(e){const t=new Map;for(const r of this._view.map?.activeLinkChartLayer?.layers??[]){const e=r;t.set(e.objectType.name,e)}const a=new Map;for(const o of e){const t=this._localEditsCache.get(o.objectId);if(t)this.initializeModifiedFeature(t,e);else{r(a,o.associatedSublayer.objectType.name,(()=>[])).push(o.objectId)}}for(const[r,o]of a){const a=t.get(r),i=a.createQuery();i.outFields=["ESRI__ID"],i.objectIds=o,a.queryFeatures(i).then((t=>{for(const r of t.features)this.initializeModifiedFeature(this.makeModifiedFeature(r,a),e)}))}}makeModifiedFeature(e,t){const r=e.attributes.ESRI__ID,a={graphic:e,layer:t,originalGraphic:e.clone(),uniqueId:r};return this._localEditsCache.set(r,a),a}initializeModifiedFeature(e,t){const r=t.filter((({objectId:t})=>t===e.uniqueId));this.modifiedFeatures.set(e,r);let a=e.graphic.geometry;const o=e.graphic.sourceLayer,s=o.parent;if(!a&&"relationship"===o.graphType){const t=s.relationshipLinkChartDiagramLookup.get(e.uniqueId);a=new i(p(t,"esriGeometryPolyline",!1,!1))}let n=a.clone();for(const{pathIndex:i,vertexIndex:c}of r)n=this.getTranslatedGeometry(a,i,c,this._totalDx,this._totalDy);e.graphic.geometry=n,s.relationshipLinkChartDiagramLookup.get(e.uniqueId)&&(s.relationshipLinkChartDiagramLookup.set(e.uniqueId,null),o.refreshCachedQueryEngine().then((()=>{o.emit("refresh",{dataChanged:!0})})))}translate(e,t){this._totalDx+=e,this._totalDy+=t;const r=new Set;for(const[a,o]of this.modifiedFeatures){let s=a.graphic.geometry;const n=a.graphic.sourceLayer,c=n.parent;if(n&&!a.graphic.geometry&&"relationship"===n.graphType){const e=c.relationshipLinkChartDiagramLookup.get(a.uniqueId);s=new i(p(e,"esriGeometryPolyline",!1,!1))}for(const i of o){if(!s)continue;const o=this.getTranslatedGeometry(s,i.pathIndex,i.vertexIndex,e,t);a.graphic.geometry=o,c.relationshipLinkChartDiagramLookup.get(a.uniqueId)&&(c.relationshipLinkChartDiagramLookup.set(a.uniqueId,null),r.add(n))}}for(const a of r)a.refreshCachedQueryEngine().then((()=>{a.emit("refresh",{dataChanged:!0})}));return Array.from(this.modifiedFeatures.keys())}getTranslatedGeometry(e,t,r,a,i){const s=new o({x:a,y:i,spatialReference:this._view.spatialReference}),c=n(s,{wkid:4326}),p=e.clone(),h=e.paths.slice();return null==h.at(t)?.at(r)||(h[t][r][0]+=c?.x??0,h[t][r][1]+=c?.y??0,p.paths=h),p}}class k extends L{constructor(e,t,r,a){super(t,a),this._connectedVerticesLookup=r;const o=[];for(const i of e){const e=this.getConnectedVerticesForFeature(i);for(const t of e)o.push(t)}this.initializeModifiedFeatures(o)}getConnectedVerticesForFeature(e){return this._connectedVerticesLookup.get(e.graphic.attributes.ESRI__ID)??[]}}export{k as ConnectedFeatureReshapeProvider,f as startNodeMovement,y as wrapperObject};
