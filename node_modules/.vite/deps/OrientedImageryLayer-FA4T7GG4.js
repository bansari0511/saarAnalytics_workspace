import {
  Xe
} from "./chunk-OJJWRUNG.js";
import "./chunk-NSG454Z6.js";
import "./chunk-HPAIQ5HK.js";
import "./chunk-6JO754WC.js";
import "./chunk-X54A5S3J.js";
import {
  A
} from "./chunk-BZSAIP56.js";
import "./chunk-QVDCF7GP.js";
import "./chunk-MDDPUBEQ.js";
import "./chunk-AZW6GDWJ.js";
import "./chunk-MFXX2MV4.js";
import "./chunk-O6RGVUWL.js";
import "./chunk-6OIIFULR.js";
import "./chunk-3B32E5HH.js";
import "./chunk-R7CNDNGI.js";
import "./chunk-ZYHGL6UN.js";
import "./chunk-ZBM5QEVD.js";
import "./chunk-DBTEUCHQ.js";
import "./chunk-MI2SWXYL.js";
import "./chunk-JL5A76NE.js";
import "./chunk-KM3CYDM4.js";
import "./chunk-2FIN3MB5.js";
import "./chunk-GBOUNRWE.js";
import "./chunk-NL2NZDM4.js";
import "./chunk-JSADYHZ3.js";
import "./chunk-5MUPVMW7.js";
import "./chunk-FBQHQDLT.js";
import {
  f
} from "./chunk-AQ3SO7BS.js";
import "./chunk-7QI7J4JB.js";
import "./chunk-IDANBZGI.js";
import "./chunk-25POTLDF.js";
import "./chunk-K54LZFQX.js";
import "./chunk-URBRKEAB.js";
import "./chunk-FT4FDH6N.js";
import "./chunk-XGN6BPAP.js";
import {
  c
} from "./chunk-CUM7BKUH.js";
import "./chunk-SIRTOV2N.js";
import "./chunk-7PK7NSON.js";
import "./chunk-NB35NLJL.js";
import "./chunk-YKZMZKSQ.js";
import "./chunk-G2PEGJ7A.js";
import "./chunk-5H6DUUYZ.js";
import "./chunk-Y2LRIJL4.js";
import "./chunk-2B7VWJ3M.js";
import "./chunk-N22DWT46.js";
import "./chunk-7BL5FEWJ.js";
import "./chunk-OAEHASLX.js";
import "./chunk-SM6D23CI.js";
import "./chunk-26WMKG2R.js";
import "./chunk-ZQUEN26P.js";
import "./chunk-66Z3HNDG.js";
import "./chunk-EU5HNJUP.js";
import "./chunk-2FZPSLPN.js";
import "./chunk-MFFIM4CO.js";
import "./chunk-GOVYB53C.js";
import "./chunk-ZLQRJCGG.js";
import "./chunk-5ONMHRRX.js";
import "./chunk-PTLGJ4Y6.js";
import "./chunk-TB5L7XWS.js";
import "./chunk-XSLTJTXI.js";
import "./chunk-KFNWBWN4.js";
import "./chunk-K55CXVYD.js";
import "./chunk-EEG2HGFZ.js";
import "./chunk-VJN4WONG.js";
import "./chunk-ERF6G26E.js";
import "./chunk-IB7M24YC.js";
import "./chunk-SE3G7TVO.js";
import "./chunk-6MQQZWN5.js";
import "./chunk-7XQTZPAU.js";
import "./chunk-UZ3YWBWC.js";
import "./chunk-K5CV62SX.js";
import "./chunk-2EOHKZLO.js";
import "./chunk-S7GLMIAQ.js";
import "./chunk-T7S34Q47.js";
import "./chunk-O4VTUNJU.js";
import "./chunk-UICDKBDP.js";
import "./chunk-3M6ALZOH.js";
import "./chunk-QPV4BKBC.js";
import "./chunk-LQQCPLIT.js";
import "./chunk-4O46EK5T.js";
import "./chunk-GQBGK7RW.js";
import "./chunk-EMULKSUV.js";
import "./chunk-AY3JR4QM.js";
import "./chunk-JVE3K2KO.js";
import "./chunk-CAHBBZSR.js";
import "./chunk-4TCHR3Y7.js";
import "./chunk-A2AZM62Y.js";
import "./chunk-5NSTYRN5.js";
import "./chunk-34AZDDDE.js";
import "./chunk-EUBRYW5A.js";
import "./chunk-2CS746FZ.js";
import "./chunk-JKIFCUQO.js";
import "./chunk-QQ2VVCKW.js";
import "./chunk-BJHD4EAD.js";
import "./chunk-NXY7NRQW.js";
import "./chunk-2BKRWNDZ.js";
import "./chunk-NSIIITDR.js";
import "./chunk-UIO6TUGM.js";
import "./chunk-3Y2NDRJ3.js";
import "./chunk-63MMKYGO.js";
import "./chunk-2OFZKHVN.js";
import "./chunk-3CFYBBSV.js";
import "./chunk-FSYN2HHU.js";
import "./chunk-CUMZN5BS.js";
import "./chunk-TAUMJOU7.js";
import "./chunk-6S55M5FH.js";
import "./chunk-ZS6XBZGY.js";
import "./chunk-FOPBVVXE.js";
import "./chunk-AACFCXAP.js";
import "./chunk-ZT7UIVVR.js";
import "./chunk-JUN27FQK.js";
import "./chunk-GIMN3QZ5.js";
import "./chunk-INI6MHIQ.js";
import "./chunk-I4VURT5T.js";
import "./chunk-QUZZIDFR.js";
import "./chunk-XNUSHDFN.js";
import {
  u
} from "./chunk-2R53FNGL.js";
import "./chunk-KA2INOMU.js";
import {
  a as a3
} from "./chunk-CUUDF5R2.js";
import "./chunk-HGJX23PN.js";
import "./chunk-N77BULFI.js";
import "./chunk-NEIJCC5O.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-XRTNDGK2.js";
import "./chunk-XLLV5QUO.js";
import "./chunk-4AKMPOG7.js";
import "./chunk-BZEUWBAD.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-2CJBZZN7.js";
import "./chunk-ZT3IR6LI.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-RKF6WUZT.js";
import "./chunk-ZBYB4REQ.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-UGTAETXR.js";
import "./chunk-GUADICE2.js";
import "./chunk-AY7ZETF7.js";
import "./chunk-NYEIVTKF.js";
import "./chunk-ZJQPHR3K.js";
import "./chunk-XK66VICH.js";
import "./chunk-HLST5KGP.js";
import "./chunk-PDFWMXUS.js";
import "./chunk-5HCEYXY5.js";
import "./chunk-H6YQECN2.js";
import {
  N
} from "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-TRJUNZSW.js";
import "./chunk-FRFSBIYZ.js";
import "./chunk-P4O4YCLI.js";
import "./chunk-FV6ZNHFI.js";
import "./chunk-IBLVGHDR.js";
import "./chunk-MSSQA3XK.js";
import "./chunk-SRNKPAJX.js";
import "./chunk-MOMLPET6.js";
import "./chunk-GYTEHLOC.js";
import "./chunk-SPNGBO6M.js";
import "./chunk-SDIBXPSJ.js";
import "./chunk-LPCUYJ2B.js";
import "./chunk-67AKDROO.js";
import {
  l
} from "./chunk-JA3AQLAK.js";
import {
  b,
  m2 as m
} from "./chunk-GWXO4XME.js";
import {
  a2
} from "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import {
  o
} from "./chunk-XNYPRDKK.js";
import "./chunk-YWPUEUEP.js";
import "./chunk-T3PXBZJ3.js";
import "./chunk-BMQ3IPHR.js";
import "./chunk-JNYZ3I5R.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import "./chunk-3QHX4R4B.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import "./chunk-N626Y23H.js";
import {
  a,
  e,
  s2 as s
} from "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-EP7EDY5M.js";

// node_modules/@arcgis/core/layers/orientedImagery/core/CameraOrientation.js
var s2 = class extends b {
  set horizontalWKID(t) {
    t ? N({ wkid: +t }) ? this._set("horizontalWKID", +t) : this._set("horizontalWKID", t) : this._set("horizontalWKID", null);
  }
  set verticalWKID(t) {
    t ? this._set("verticalWKID", isFinite(t) && N({ wkid: +t }) ? +t : null) : this._set("verticalWKID", null);
  }
  get isAdvanced() {
    const { affineTransformations: t, focalLength: o2, principalOffsetPoint: e2, radialDistortionCoefficients: r2, tangentialDistortionCoefficients: i2 } = this;
    return t?.length > 1 && !Number.isNaN(o2) && e2?.length > 1 && r2?.length > 1 && i2?.length > 1;
  }
};
r([m({ json: { write: true } })], s2.prototype, "affineTransformations", void 0), r([m({ json: { write: true } })], s2.prototype, "focalLength", void 0), r([m({ json: { write: true } })], s2.prototype, "principalOffsetPoint", void 0), r([m({ json: { write: true } })], s2.prototype, "radialDistortionCoefficients", void 0), r([m({ json: { write: true } })], s2.prototype, "tangentialDistortionCoefficients", void 0), r([m({ json: { write: true } })], s2.prototype, "horizontalWKID", null), r([m({ json: { write: true } })], s2.prototype, "verticalWKID", null), r([m({ json: { write: true } })], s2.prototype, "x", void 0), r([m({ json: { write: true } })], s2.prototype, "y", void 0), r([m({ json: { write: true } })], s2.prototype, "z", void 0), r([m({ json: { write: true } })], s2.prototype, "type", void 0), s2 = r([a2("esri.layers.orientedImagery.core.CameraOrientation")], s2);
var n = s2;

// node_modules/@arcgis/core/layers/orientedImagery/core/CameraOrientationHPR.js
var s3 = class extends a3.ClonableMixin(l.JSONSupportMixin(n)) {
  constructor() {
    super(...arguments), this.type = 1;
  }
  toString() {
    const { type: o2, horizontalWKID: t, verticalWKID: r2, x: e2, y: i2, z: p4, heading: s5, pitch: n7, roll: a5, affineTransformations: c4, focalLength: m3, principalOffsetPoint: f3, radialDistortionCoefficients: y2, tangentialDistortionCoefficients: u3 } = this, d2 = [o2, t, r2, e2, i2, p4, s5, n7, a5];
    return this.isAdvanced && (c4?.forEach(((o3) => d2.push(o3))), d2.push(m3), f3?.forEach(((o3) => d2.push(o3))), y2?.forEach(((o3) => d2.push(o3))), u3?.forEach(((o3) => d2.push(o3)))), d2.map(((o3) => Number.isNaN(o3) ? "" : o3)).join("|");
  }
};
r([m({ json: { write: true } })], s3.prototype, "type", void 0), r([m({ type: [Number], json: { write: true } })], s3.prototype, "affineTransformations", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "focalLength", void 0), r([m({ type: [Number], json: { write: true } })], s3.prototype, "principalOffsetPoint", void 0), r([m({ type: [Number], json: { write: true } })], s3.prototype, "radialDistortionCoefficients", void 0), r([m({ type: [Number], json: { write: true } })], s3.prototype, "tangentialDistortionCoefficients", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "heading", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "pitch", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "roll", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "x", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "y", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "z", void 0), s3 = r([a2("esri.layers.orientedImagery.core.CameraOrientationHPR")], s3);
var n2 = s3;

// node_modules/@arcgis/core/layers/orientedImagery/core/CameraOrientationLTP.js
var p = class extends a3.ClonableMixin(l.JSONSupportMixin(n)) {
  constructor() {
    super(...arguments), this.type = 4;
  }
  toString() {
    const { type: o2, latitude: r2, longitude: t, ellipsoidRadius: e2, squaredEccentricity: i2, properties: s5 } = this, p4 = `${s5}`.split("|");
    return p4.splice(1, 1), `${o2}|${r2}|${t}|${e2}|${i2}|${p4.join("|")}`;
  }
};
r([m({ json: { write: true } })], p.prototype, "type", void 0), r([m({ json: { write: true }, type: Number })], p.prototype, "latitude", void 0), r([m({ json: { write: true }, type: Number })], p.prototype, "longitude", void 0), r([m({ json: { write: true }, type: Number })], p.prototype, "ellipsoidRadius", void 0), r([m({ json: { write: true }, type: Number })], p.prototype, "squaredEccentricity", void 0), r([m({ json: { write: true } })], p.prototype, "properties", void 0), p = r([a2("esri.layers.orientedImagery.core.CameraOrientationLTP")], p);
var c2 = p;

// node_modules/@arcgis/core/layers/orientedImagery/core/CameraOrientationOPK.js
var s4 = class extends a3.ClonableMixin(l.JSONSupportMixin(n)) {
  constructor() {
    super(...arguments), this.type = 2;
  }
  toString() {
    const { type: o2, horizontalWKID: t, verticalWKID: r2, x: e2, y: i2, z: p4, omega: s5, phi: n7, kappa: a5, affineTransformations: c4, focalLength: m3, principalOffsetPoint: f3, radialDistortionCoefficients: y2, tangentialDistortionCoefficients: u3 } = this, d2 = [o2, t, r2, e2, i2, p4, s5, n7, a5];
    return this.isAdvanced && (c4?.forEach(((o3) => d2.push(o3))), d2.push(m3), f3?.forEach(((o3) => d2.push(o3))), y2?.forEach(((o3) => d2.push(o3))), u3?.forEach(((o3) => d2.push(o3)))), d2.map(((o3) => isNaN(o3) ? "" : o3)).join("|");
  }
};
r([m({ json: { write: true } })], s4.prototype, "type", void 0), r([m({ type: [Number], json: { write: true } })], s4.prototype, "affineTransformations", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "focalLength", void 0), r([m({ type: [Number], json: { write: true } })], s4.prototype, "principalOffsetPoint", void 0), r([m({ type: [Number], json: { write: true } })], s4.prototype, "radialDistortionCoefficients", void 0), r([m({ type: [Number], json: { write: true } })], s4.prototype, "tangentialDistortionCoefficients", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "omega", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "phi", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "kappa", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "x", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "y", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "z", void 0), s4 = r([a2("esri.layers.orientedImagery.core.CameraOrientationOPK")], s4);
var n3 = s4;

// node_modules/@arcgis/core/layers/orientedImagery/core/CameraOrientationYPR.js
var n4 = class extends a3.ClonableMixin(l.JSONSupportMixin(n)) {
  constructor() {
    super(...arguments), this.type = 3;
  }
  get isAdvanced() {
    const { affineTransformations: o2, focalLength: t, principalOffsetPoint: e2, radialDistortionCoefficients: r2, tangentialDistortionCoefficients: i2 } = this;
    return o2?.length > 1 || !Number.isNaN(t) || e2?.length > 1 || r2?.length > 1 || i2?.length > 1;
  }
  toString() {
    const { type: o2, horizontalWKID: t, verticalWKID: e2, x: r2, y: i2, z: s5, yaw: n7, pitch: p4, roll: a5, affineTransformations: c4, focalLength: f3, principalOffsetPoint: m3, radialDistortionCoefficients: y2, tangentialDistortionCoefficients: l3 } = this, u3 = [o2, t, e2, r2, i2, s5, n7, p4, a5];
    return this.isAdvanced && (c4?.forEach(((o3) => u3.push(o3))), u3.push(f3), m3?.forEach(((o3) => u3.push(o3))), m3?.forEach(((o3) => u3.push(o3))), y2?.forEach(((o3) => u3.push(o3))), l3?.forEach(((o3) => u3.push(o3)))), u3.map(((o3) => Number.isNaN(o3) ? "" : o3)).join("|");
  }
};
r([m({ json: { write: true } })], n4.prototype, "type", void 0), r([m({ type: [Number], json: { write: true } })], n4.prototype, "affineTransformations", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "focalLength", void 0), r([m({ type: [Number], json: { write: true } })], n4.prototype, "principalOffsetPoint", void 0), r([m({ type: [Number], json: { write: true } })], n4.prototype, "radialDistortionCoefficients", void 0), r([m({ type: [Number], json: { write: true } })], n4.prototype, "tangentialDistortionCoefficients", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "yaw", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "pitch", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "roll", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "x", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "y", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "z", void 0), n4 = r([a2("esri.layers.orientedImagery.core.CameraOrientationYPR")], n4);
var p2 = n4;

// node_modules/@arcgis/core/layers/orientedImagery/enums/CameraOrientationType.js
var P;
!(function(P3) {
  P3[P3.HPR = 1] = "HPR", P3[P3.OPK = 2] = "OPK", P3[P3.YPR = 3] = "YPR", P3[P3.LTP = 4] = "LTP";
})(P || (P = {}));

// node_modules/@arcgis/core/layers/orientedImagery/core/cameraOrientationRegistry.js
var n5 = /* @__PURE__ */ new Map();
n5.set(`${P.OPK}`, { desc: "Using Omega Phi Kappa", constructor: n3 }), n5.set(`${P.HPR}`, { desc: "Using Heading, Pitch and Roll", constructor: n2 }), n5.set(`${P.YPR}`, { desc: "Using Yaw, Pitch and Roll", constructor: p2 }), n5.set(`${P.LTP}`, { desc: "Using Local Tangent Plane", constructor: c2 });

// node_modules/@arcgis/core/layers/orientedImagery/core/ElevationSourceDefinitions.js
var n6 = class extends a3.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.url = null;
  }
};
r([m({ type: Number, json: { write: true } })], n6.prototype, "lod", void 0), r([m({ type: String, json: { write: true } })], n6.prototype, "rasterFunction", void 0), r([m({ type: String, json: { write: true } })], n6.prototype, "url", void 0), n6 = r([a2("esri.layers.orientedImagery.core.ElevationSourceDefinitions.ElevationSource")], n6);
var i = class extends a3.ClonableMixin(l) {
  constructor() {
    super(...arguments), this.constantElevation = null;
  }
};
r([m({ type: Number, json: { write: true } })], i.prototype, "constantElevation", void 0), i = r([a2("esri.layers.orientedImagery.core.ElevationSourceDefinitions.ConstantElevation")], i);
var l2 = (o2) => null != o2 && "number" == typeof o2.constantElevation;

// node_modules/@arcgis/core/layers/orientedImagery/core/utils.js
function a4(e2, t, r2) {
  return t && (e2 = `${t}${e2}`), r2 && (e2 += `${r2}`), e2;
}
function u2(e2, t, r2) {
  let { url: n7 } = e2;
  return n7 ? (n7 = a4(n7, t, r2), new n6({ ...e2, url: n7 })) : null;
}
function c3(e2, t, r2) {
  return e2 ? l2(e2) ? new i(e2) : u2(e2, t, r2) : e2;
}
var f2 = new o({ Minutes: "minutes", Hours: "hours", Days: "days", Weeks: "weeks", Months: "months", Years: "years" });
var p3 = new o({ Feet: "feet", Meter: "meter" });
var m2 = new o({ 360: "360", Horizontal: "horizontal", Inspection: "inspection", Nadir: "nadir", Oblique: "oblique", Terrestrial360Video: "terrestrial-360-video", TerrestrialFrameVideo: "terrestrial-frame-video", Aerial360Video: "aerial-360-video", AerialFrameVideo: "aerial-frame-video", "": null });
var h = /* @__PURE__ */ new Map();
function g(e2) {
  const [t, r2, n7, i2, o2, s5, l3, a5, u3, c4, f3, p4, m3, h2, g3, d2, w2, v3, D2, z, $2, j4] = e2.slice(1);
  return { horizontalWKID: t, verticalWKID: r2, x: n7, y: i2, z: o2, omega: s5, phi: l3, kappa: a5, ...y([u3, c4, f3, p4, m3, h2], [d2, w2], [v3, D2, z], [$2, j4], g3) };
}
h.set(`${P.HPR}`, w), h.set(`${P.YPR}`, v), h.set(`${P.OPK}`, g), h.set(`${P.LTP}`, D);
var d = (e2) => {
  const t = e2.map(((e3) => parseFloat(e3))).filter(((e3) => !isNaN(e3)));
  if (t.length === e2.length) return t;
};
function y(e2, t, r2, n7, i2) {
  const o2 = d(e2), s5 = d(t), l3 = d(r2), a5 = d(n7);
  return { affineTransformations: 6 === o2?.length ? o2 : void 0, focalLength: 6 === o2?.length ? parseFloat(i2) : void 0, principalOffsetPoint: 2 !== s5?.length ? [0, 0] : s5, radialDistortionCoefficients: 3 !== l3?.length ? [0, 0, 0] : l3, tangentialDistortionCoefficients: 2 !== a5?.length ? [0, 0] : a5 };
}
function w(e2) {
  const [t, r2, n7, i2, o2, s5, l3, a5, u3, c4, f3, p4, m3, h2, g3, d2, w2, v3, D2, z, $2, j4] = e2.slice(1);
  return { horizontalWKID: t, verticalWKID: r2, x: n7, y: i2, z: o2, heading: s5, pitch: l3, roll: a5, ...y([u3, c4, f3, p4, m3, h2], [d2, w2], [v3, D2, z], [$2, j4], g3) };
}
function v(e2) {
  const [t, r2, n7, i2, o2, s5, l3, a5, u3, c4, f3, p4, m3, h2, g3, d2, w2, v3, D2, z, $2, j4] = e2.slice(1);
  return { horizontalWKID: t, verticalWKID: r2, x: n7, y: i2, z: o2, yaw: s5, pitch: l3, roll: a5, ...y([u3, c4, f3, p4, m3, h2], [d2, w2], [v3, D2, z], [$2, j4], g3) };
}
function D(e2) {
  const [t, r2, i2, o2, s5, ...l3] = e2.slice(1), a5 = h.get(s5), u3 = n5.get(s5)?.constructor;
  if (!a5 || !u3) return null;
  return { latitude: t, longitude: r2, ellipsoidRadius: i2, squaredEccentricity: o2, properties: new u3(a5([s5, "", ...l3])) };
}
function $(e2) {
  return Array.isArray(e2) && e2?.length > 5 && !e2.some(isNaN);
}
function j2(e2) {
  for (e2 = e2.slice(0, 8); e2.length < 8; ) e2.push(0);
  return e2;
}

// node_modules/@arcgis/core/layers/OrientedImageryLayer.js
var g2 = /* @__PURE__ */ new Set(["demPathPrefix", "demPathSuffix", "depthImagePathPrefix", "depthImagePathSuffix", "elevationSource", "horizontalMeasurementUnit", "imageGeometryField", "imageReferenceField", "referenceIDField", "sequenceOrderField", "verticalMeasurementUnit", "videoPathPrefix", "videoPathSuffix", "timeAnimation", "visibilityTimeExtent"]);
var v2 = (e2, t) => !g2.has(t) && e2;
var j3 = (e2, t, i2) => {
  const r2 = `orientedImageryProperties.${e2}`;
  return { name: r2, write: t ? { ignoreOrigin: true, target: r2, writer: t } : { ignoreOrigin: true }, read: i2 ? { ignoreOrigin: true, source: r2, reader: i2 } : { ignoreOrigin: true } };
};
function P2(e2) {
  return e2.json ? (e2.json.origins = e2.json.origins ?? {}, e2.json.origins["web-scene"] = { write: false, read: false }, e2) : e2;
}
function S(e2, t, i2, r2) {
  const { name: o2, write: a5, read: n7 } = j3(e2, t, i2), s5 = { name: o2, write: a5, read: n7, origins: { service: { name: `orientedImageryInfo.${o2}`, write: t, read: i2 }, "web-scene": { name: o2, write: v2(a5, e2), read: v2(n7, e2) }, "web-map": { name: o2, write: a5, read: n7 } } };
  return r2 && s5.origins ? (s5.type = r2, s5.origins["web-map"].type = r2, s5.origins["web-scene"].type = r2, s5) : s5;
}
var x = class extends Xe {
  constructor() {
    super(...arguments), this.attributeTableTemplate = null, this.cameraHeading = null, this.cameraHeight = null, this.cameraPitch = null, this.cameraRoll = null, this.coveragePercent = null, this.demPathPrefix = null, this.demPathSuffix = null, this.depthImagePathPrefix = null, this.depthImagePathSuffix = null, this.elevationSource = null, this.farDistance = null, this.geometryType = "point", this.horizontalFieldOfView = null, this.horizontalMeasurementUnit = null, this.imageGeometryField = "ImageGeometry", this.imagePathPrefix = null, this.imagePathSuffix = null, this.imageReferenceField = "OIObjectID", this.imageRotation = null, this.maximumDistance = null, this.nearDistance = null, this.operationalLayerType = "OrientedImageryLayer", this.orientationAccuracy = null, this.orientedImageryType = null, this.referenceIDField = "OBJECTID", this.sequenceOrderField = "SequenceOrder", this.supportedSourceTypes = /* @__PURE__ */ new Set(["Oriented Imagery Layer"]), this.type = "oriented-imagery", this.timeIntervalUnit = "days", this.useViewTime = true, this.verticalFieldOfView = null, this.verticalMeasurementUnit = null, this.videoPathPrefix = null, this.videoPathSuffix = null, this.visibilityTimeExtent = null;
  }
  get effectiveElevationSource() {
    const { elevationSource: e2, demPathPrefix: t, demPathSuffix: i2 } = this;
    return c3(e2, t, i2);
  }
  async save(e2) {
    return this._debouncedSaveOperations(A.SAVE, e2);
  }
  async saveAs(e2, t) {
    return this._debouncedSaveOperations(A.SAVE_AS, t, e2);
  }
  findFirstValidLayerId(e2) {
    return e2.layers?.find(((e3) => this.supportedSourceTypes.has(e3.type)))?.id;
  }
  _verifySource() {
    if (super._verifySource(), "point" !== this.geometryType) throw new s("oriented-imagery-layer:invalid-geometry-type", "OrientedImageryLayer only supports point geometry type");
  }
};
r([m({ type: c, json: { write: false, read: false } })], x.prototype, "attributeTableTemplate", void 0), r([m({ type: Number, json: S("cameraHeading") })], x.prototype, "cameraHeading", void 0), r([m({ type: Number, json: S("cameraHeight") })], x.prototype, "cameraHeight", void 0), r([m({ type: Number, json: S("cameraPitch") })], x.prototype, "cameraPitch", void 0), r([m({ type: Number, json: S("cameraRoll") })], x.prototype, "cameraRoll", void 0), r([m({ type: Number, json: S("coveragePercent") })], x.prototype, "coveragePercent", void 0), r([m({ type: String, json: S("demPathPrefix") })], x.prototype, "demPathPrefix", void 0), r([m({ type: String, json: S("demPathSuffix") })], x.prototype, "demPathSuffix", void 0), r([m({ type: String, json: S("depthImagePathPrefix") })], x.prototype, "depthImagePathPrefix", void 0), r([m({ type: String, json: S("depthImagePathSuffix") })], x.prototype, "depthImagePathSuffix", void 0), r([m({ type: Object, json: S("elevationSource") })], x.prototype, "elevationSource", void 0), r([m({ readOnly: true })], x.prototype, "effectiveElevationSource", null), r([m({ type: Number, json: S("farDistance") })], x.prototype, "farDistance", void 0), r([m()], x.prototype, "geometryType", void 0), r([m({ type: Number, json: S("horizontalFieldOfView") })], x.prototype, "horizontalFieldOfView", void 0), r([m({ type: String, json: S("horizontalMeasurementUnit") })], x.prototype, "horizontalMeasurementUnit", void 0), r([m({ type: String, json: { ...S("imageGeometryField"), default: "ImageGeometry" } })], x.prototype, "imageGeometryField", void 0), r([m({ type: String, json: S("imagePathPrefix") })], x.prototype, "imagePathPrefix", void 0), r([m({ type: String, json: S("imagePathSuffix") })], x.prototype, "imagePathSuffix", void 0), r([m({ type: String, json: { ...S("imageReferenceField"), default: "OIObjectID" } })], x.prototype, "imageReferenceField", void 0), r([m({ type: Number, json: S("imageRotation") })], x.prototype, "imageRotation", void 0), r([m({ type: Number, json: S("maximumDistance") })], x.prototype, "maximumDistance", void 0), r([m({ type: Number, json: S("nearDistance") })], x.prototype, "nearDistance", void 0), r([m({ type: ["OrientedImageryLayer"], json: { origins: { "portal-item": { name: "layerType", write: { enabled: true, ignoreOrigin: true } } } } })], x.prototype, "operationalLayerType", void 0), r([m({ json: { ...S("orientationAccuracy", ((e2, t, i2) => {
  e(i2, e2.join(";"), t);
}), ((e2) => {
  const t = e2?.split(";")?.map(Number);
  return $(t) ? j2(t) : [0, 0, 0, 0, 0, 0, 0, 0];
}), String) } })], x.prototype, "orientationAccuracy", void 0), r([m({ json: { ...S("orientedImageryType", m2.write, m2.read, m2.jsonValues.slice(1)) } })], x.prototype, "orientedImageryType", void 0), r([m({ type: String, json: { ...S("referenceIDField"), default: "OBJECTID" } })], x.prototype, "referenceIDField", void 0), r([m({ type: String, json: { ...S("sequenceOrderField"), default: "SequenceOrder" } })], x.prototype, "sequenceOrderField", void 0), r([m({ json: { read: false }, value: "oriented-imagery", readOnly: true })], x.prototype, "type", void 0), r([m({ type: f2.apiValues, json: { ...S("timeIntervalUnit", f2.write, f2.read, f2.jsonValues) } })], x.prototype, "timeIntervalUnit", void 0), r([m(P2(a(f)))], x.prototype, "useViewTime", void 0), r([m({ type: Number, json: S("verticalFieldOfView") })], x.prototype, "verticalFieldOfView", void 0), r([m({ type: p3.apiValues, json: { ...S("verticalMeasurementUnit", p3.write, p3.read, p3.jsonValues) } })], x.prototype, "verticalMeasurementUnit", void 0), r([m({ type: String, json: S("videoPathPrefix") })], x.prototype, "videoPathPrefix", void 0), r([m({ type: String, json: S("videoPathSuffix") })], x.prototype, "videoPathSuffix", void 0), r([m({ type: u, json: { origins: { "web-scene": { write: false, read: false } } } })], x.prototype, "visibilityTimeExtent", void 0), x = r([a2("esri.layers.OrientedImageryLayer")], x);
var b2 = x;
export {
  b2 as default
};
//# sourceMappingURL=OrientedImageryLayer-FA4T7GG4.js.map
