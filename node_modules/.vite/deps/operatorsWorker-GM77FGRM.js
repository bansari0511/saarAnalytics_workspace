import {
  f
} from "./chunk-ZS6XBZGY.js";
import "./chunk-ZBYB4REQ.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-UGTAETXR.js";
import "./chunk-ZJQPHR3K.js";
import "./chunk-XK66VICH.js";
import "./chunk-HLST5KGP.js";
import "./chunk-PDFWMXUS.js";
import "./chunk-5HCEYXY5.js";
import "./chunk-H6YQECN2.js";
import "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-TRJUNZSW.js";
import "./chunk-67AKDROO.js";
import "./chunk-JA3AQLAK.js";
import "./chunk-GWXO4XME.js";
import "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import "./chunk-YWPUEUEP.js";
import "./chunk-T3PXBZJ3.js";
import "./chunk-BMQ3IPHR.js";
import "./chunk-JNYZ3I5R.js";
import "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import "./chunk-N626Y23H.js";
import "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-EP7EDY5M.js";

// node_modules/@arcgis/core/arcade/geometry/operatorsWorker.js
function t(e, t2) {
  let r2;
  return { loaded: false, load: () => r2 ??= t2().then(((t3) => {
    o[e] = { loaded: true, execute: t3 };
  })) };
}
function r(e) {
  return null == e ? null : e.toJSON();
}
var o = { disjoint: t("disjoint", (() => import("./disjointOperator-G6KXZRGQ.js").then(((e) => e.execute)))), intersects: t("intersects", (() => import("./intersectsOperator-JHDNZYQQ.js").then(((e) => e.execute)))), touches: t("touches", (() => import("./touchesOperator-US34CDB4.js").then(((e) => e.execute)))), crosses: t("crosses", (() => import("./crossesOperator-C6SCJ56G.js").then(((e) => e.execute)))), within: t("within", (() => import("./withinOperator-2N55IOK5.js").then(((e) => e.execute)))), contains: t("contains", (() => import("./containsOperator-CTTJ6WVU.js").then(((e) => e.execute)))), overlaps: t("overlaps", (() => import("./overlapsOperator-XHH2DGSB.js").then(((e) => e.execute)))), equals: t("equals", (async () => {
  const t2 = await import("./equalsOperator-QX4MV6MI.js");
  return (r2, o2) => t2.execute(f(r2), f(o2));
})), relate: t("relate", (async () => {
  const t2 = await import("./relateOperator-ZVXW4LJG.js");
  return (r2, o2, n2) => t2.execute(f(r2), f(o2), n2);
})), intersection: t("intersection", (() => import("./intersectionOperator-VPIOFJB7.js").then(((e) => e.execute)))), union: t("union", (() => import("./unionOperator-M7QL7DEO.js").then(((e) => e.executeMany)))), difference: t("difference", (async () => {
  const t2 = await import("./differenceOperator-HXNSJNAC.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
})), symmetricDifference: t("symmetricDifference", (async () => {
  const t2 = await import("./symmetricDifferenceOperator-4XEFTEJ2.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
})), clip: t("clip", (async () => {
  const t2 = await import("./clipOperator-J5J7ZGKS.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
})), cut: t("cut", (async () => {
  const t2 = await import("./cutOperator-2IGASLB5.js");
  return (o2, n2) => t2.execute(f(o2), f(n2)).map(((e) => r(e)));
})), area: t("area", (async () => {
  const t2 = await import("./areaOperator-NMCHXLZ5.js"), { convertFromSpatialReferenceUnit: r2, toAreaUnit: o2 } = await import("./unitConversion-FZZJDREM.js");
  return (n2, a) => {
    const s = t2.execute(f(n2));
    return r2(n2.spatialReference, o2(a), s);
  };
})), geodeticArea: t("geodeticArea", (async () => {
  const t2 = await import("./geodeticAreaOperator-E7TZOBXC.js"), { convert: r2, squareMeters: o2, toAreaUnit: n2 } = await import("./unitConversion-FZZJDREM.js");
  return await t2.load(), (a, s, i) => {
    const c = t2.execute(f(a), { curveType: i });
    return r2(o2, n2(s), c);
  };
})), length: t("length", (async () => {
  const e = await import("./lengthOperator-ZOILDG4H.js"), { convertFromSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-FZZJDREM.js");
  return (o2, n2) => {
    const a = e.execute(o2);
    return t2(o2.spatialReference, r2(n2), a);
  };
})), geodeticLength: t("geodeticLength", (async () => {
  const t2 = await import("./geodeticLengthOperator-LP66FRXG.js"), { convert: r2, meters: o2, toLengthUnit: n2 } = await import("./unitConversion-FZZJDREM.js");
  return await t2.load(), (a, s, i) => {
    const c = t2.execute(f(a), { curveType: i });
    return r2(o2, n2(s), c);
  };
})), distance: t("distance", (async () => {
  const t2 = await import("./distanceOperator-52INUXEC.js"), { convertFromSpatialReferenceUnit: r2, toLengthUnit: o2 } = await import("./unitConversion-FZZJDREM.js");
  return (n2, a, s) => {
    const i = t2.execute(f(n2), f(a));
    return r2(n2.spatialReference, o2(s), i);
  };
})), densify: t("densify", (async () => {
  const t2 = await import("./densifyOperator-WBXUH2FX.js"), { convertToSpatialReferenceUnit: o2, toLengthUnit: n2 } = await import("./unitConversion-FZZJDREM.js");
  return (a, s, i) => (s = o2(n2(i), a.spatialReference, s), r(t2.execute(f(a), s)));
})), geodeticDensify: t("geodeticDensify", (async () => {
  const t2 = await import("./geodeticDensifyOperator-JCC4RLQK.js"), { convert: o2, meters: n2, toLengthUnit: a } = await import("./unitConversion-FZZJDREM.js");
  return await t2.load(), (s, i, c, p) => (i = o2(a(c), n2, i), r(t2.execute(f(s), i, { curveType: p })));
})), generalize: t("generalize", (async () => {
  const t2 = await import("./generalizeOperator-OAWGYHFH.js"), { convertToSpatialReferenceUnit: o2, toLengthUnit: n2 } = await import("./unitConversion-FZZJDREM.js");
  return (a, s, i, c) => (s = o2(n2(i), a.spatialReference, s), r(t2.execute(f(a), s, c)));
})), buffer: t("buffer", (async () => {
  const e = await import("./bufferOperator-L5WUXXJT.js"), { convertToSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-FZZJDREM.js");
  return (o2, n2, a) => (n2 = t2(r2(a), o2.spatialReference, n2), e.execute(o2, n2));
})), geodesicBuffer: t("geodesicBuffer", (async () => {
  const e = await import("./geodesicBufferOperator-MHWQMWXL.js"), { convert: t2, meters: r2, toLengthUnit: o2 } = await import("./unitConversion-FZZJDREM.js");
  return await e.load(), (n2, a, s, i) => (a = t2(o2(s), r2, a), e.execute(n2, a, { curveType: i }));
})), offset: t("offset", (async () => {
  const e = await import("./offsetOperator-UIIGBEIN.js"), { convertToSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-FZZJDREM.js");
  return (o2, n2, a, s) => (n2 = t2(r2(a), o2.spatialReference, n2), e.execute(o2, n2, s));
})), rotate: t("rotate", (async () => {
  const t2 = await import("./affineTransformOperator-NR6TPO7F.js"), { default: o2 } = await import("./Transformation-DPAB5YPG.js");
  return (n2, a, s, i) => {
    const c = new o2().rotate(a, s, i);
    return r(t2.execute(f(n2), c));
  };
})), centroid: t("centroid", (async () => {
  const t2 = await import("./centroidOperator-JHDF6KSI.js");
  return (o2) => r(t2.execute(f(o2)));
})), labelPoint: t("labelPoint", (async () => {
  const t2 = await import("./labelPointOperator-N7G2G6YM.js");
  return (o2) => r(t2.execute(f(o2)));
})), simplify: t("simplify", (() => import("./simplifyOperator-52VKYUTX.js").then(((e) => e.execute)))), isSelfIntersecting: t("isSelfIntersecting", (async () => {
  const { NonSimpleResult: t2 } = await import("./OperatorDefinitions-4CVIXAP6.js"), r2 = await import("./simplifyOGCOperator-5BJNWPIW.js"), o2 = /* @__PURE__ */ new Set([5, 6, 7, 10, 11, 12]);
  return (n2) => {
    const a = new t2();
    return !r2.isSimple(f(n2), a) && o2.has(a.m_reason);
  };
})), isSimple: t("isSimple", (() => import("./simplifyOperator-52VKYUTX.js").then(((e) => e.isSimple)))), convexHull: t("convexHull", (() => import("./convexHullOperator-5HBPDFXZ.js").then(((e) => e.execute)))), getNearestCoordinate: t("getNearestCoordinate", (async () => {
  const t2 = await import("./proximityOperator-3WQHMDSQ.js");
  return (o2, n2, a) => {
    const s = t2.getNearestCoordinate(f(o2), f(n2), a);
    return { ...s, coordinate: r(s.coordinate) };
  };
})), getNearestVertex: t("getNearestVertex", (async () => {
  const t2 = await import("./proximityOperator-3WQHMDSQ.js");
  return (o2, n2) => {
    const a = t2.getNearestVertex(f(o2), f(n2));
    return { ...a, coordinate: r(a.coordinate) };
  };
})) };
function n(e, t2) {
  const r2 = o[e];
  return r2.loaded ? r2.execute.apply(void 0, t2) : r2.load().then((() => n(e, t2)));
}
export {
  n as invokeGeometryOp
};
//# sourceMappingURL=operatorsWorker-GM77FGRM.js.map
