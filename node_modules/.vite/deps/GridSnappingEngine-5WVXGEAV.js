import {
  r as r2
} from "./chunk-TSQV6EJG.js";
import "./chunk-IE6QJMDY.js";
import {
  r as r3
} from "./chunk-TA34CXSD.js";
import "./chunk-3KDNHMA3.js";
import {
  d
} from "./chunk-P7DAUEX3.js";
import {
  c,
  f
} from "./chunk-37USNU2Q.js";
import {
  l,
  t,
  u as u2
} from "./chunk-VYDV6ZE4.js";
import "./chunk-4LD5ZNXN.js";
import "./chunk-WHNSSW5C.js";
import "./chunk-RHVCSVQD.js";
import "./chunk-MJTI6OYZ.js";
import {
  u
} from "./chunk-GBOUNRWE.js";
import "./chunk-TOD32WVA.js";
import "./chunk-DTPLSS5W.js";
import "./chunk-HPADPQJ7.js";
import "./chunk-3JKWT76Y.js";
import "./chunk-LOLNWH3R.js";
import "./chunk-UZ3YWBWC.js";
import "./chunk-2EOHKZLO.js";
import "./chunk-3M6ALZOH.js";
import "./chunk-QPV4BKBC.js";
import "./chunk-544X4ER5.js";
import "./chunk-CA5QK7QF.js";
import "./chunk-5WW35KU4.js";
import "./chunk-WX3VZIBK.js";
import "./chunk-A2AZM62Y.js";
import "./chunk-2RL34CVC.js";
import "./chunk-BNQMKYX6.js";
import "./chunk-B6C2GOG6.js";
import {
  w
} from "./chunk-K3VYMAVM.js";
import "./chunk-NSIIITDR.js";
import "./chunk-UIO6TUGM.js";
import "./chunk-3Y2NDRJ3.js";
import {
  P
} from "./chunk-FUCT7A5P.js";
import "./chunk-QTS3VC6A.js";
import "./chunk-EVAICJFZ.js";
import "./chunk-2CRE6SXL.js";
import "./chunk-63MMKYGO.js";
import "./chunk-2OFZKHVN.js";
import "./chunk-3CFYBBSV.js";
import "./chunk-MWVR4HFA.js";
import "./chunk-ZS6XBZGY.js";
import "./chunk-AACFCXAP.js";
import "./chunk-P5DG4SNT.js";
import "./chunk-2R53FNGL.js";
import "./chunk-CUUDF5R2.js";
import {
  O,
  U
} from "./chunk-XYME6BO6.js";
import "./chunk-N77BULFI.js";
import "./chunk-NEIJCC5O.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-XRTNDGK2.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-ZT3IR6LI.js";
import "./chunk-RKF6WUZT.js";
import "./chunk-ZBYB4REQ.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-UGTAETXR.js";
import {
  s
} from "./chunk-ZJQPHR3K.js";
import "./chunk-XK66VICH.js";
import "./chunk-HLST5KGP.js";
import "./chunk-PDFWMXUS.js";
import "./chunk-5HCEYXY5.js";
import "./chunk-H6YQECN2.js";
import {
  j
} from "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-TRJUNZSW.js";
import "./chunk-IBLVGHDR.js";
import "./chunk-SRNKPAJX.js";
import "./chunk-MOMLPET6.js";
import "./chunk-SDIBXPSJ.js";
import "./chunk-LPCUYJ2B.js";
import "./chunk-67AKDROO.js";
import "./chunk-JA3AQLAK.js";
import {
  b,
  m2 as m
} from "./chunk-GWXO4XME.js";
import {
  a2 as a
} from "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import "./chunk-YWPUEUEP.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import "./chunk-3QHX4R4B.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import "./chunk-SH3CUEMB.js";
import "./chunk-BMQ3IPHR.js";
import "./chunk-JNYZ3I5R.js";
import "./chunk-N626Y23H.js";
import {
  i3 as i
} from "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-EP7EDY5M.js";

// node_modules/@arcgis/core/views/interactive/snapping/GridSnappingEngine.js
var w2 = class extends b {
  constructor(t2) {
    super(t2), this.options = null;
  }
  destroy() {
    this._set("options", null);
  }
  get grid() {
    return this.view.grid;
  }
  get effectiveViewRotation() {
    return this.grid?.rotateWithMap ? 0 : s(this.view.rotation ?? 0);
  }
  get gridRotation() {
    return s(this.grid?.rotation ?? 0);
  }
  get gridCenter() {
    const { spatialReference: t2, grid: e } = this;
    if (!e || !t2 || !U(e.center.spatialReference, t2)) return null;
    try {
      const r4 = O(e.center, t2), i2 = t2.isWrappable && null != this.view?.center ? P(r4.x, this.view.center.x, t2) : r4.x;
      return f(i2, r4.y, r4.z);
    } catch (i2) {
      return i.getLogger(this).errorOnce("Grid Snapping - Failed to project grid center.", i2), null;
    }
  }
  get offsetScaleFactor() {
    const { pixelsPerStride: t2, grid: e } = this;
    if (!e || !t2) return 1;
    const { majorLineInterval: r4, dynamicScaling: i2 } = e;
    return r4 < 1 ? null : l(r4, t2, i2);
  }
  get spatialReference() {
    return this.view.spatialReference;
  }
  get gridMetersPerStride() {
    const { grid: t2 } = this;
    return t2 ? j(t2.spacing, t2.units, "meters") : null;
  }
  get viewMetersPerPixel() {
    const { viewMetersPerSRUnit: t2 } = this;
    return null == t2 ? null : t2 * u(this.view.scale, this.view.spatialReference);
  }
  get viewMetersPerSRUnit() {
    const { spatialReference: t2 } = this.view;
    return this.gridCenter ? u2(this.gridCenter[0], this.gridCenter[1], t2) : null;
  }
  get pixelsPerStride() {
    const { gridMetersPerStride: t2, viewMetersPerPixel: e } = this;
    return e && t2 ? t2 / e : null;
  }
  get updating() {
    return null != this.grid && null != this.spatialReference && null == this.viewMetersPerSRUnit;
  }
  async fetchCandidates(t2, e, r4) {
    const { options: i2, view: n } = this;
    if (!i2?.effectiveGridEnabled || !n.grid || r4.feature?.attributes && d in r4.feature.attributes) return [];
    const o = r4.coordinateHelper.arrayToPoint(t2), s2 = i2.distance * ("touch" === r4.pointer ? i2.touchSensitivityMultiplier : 1);
    return this.fetchCandidatesSync(o, s2);
  }
  fetchCandidatesSync(t2, e) {
    const r4 = [], { grid: i2, effectiveViewRotation: n, gridRotation: o, gridCenter: s2, viewMetersPerPixel: a2, viewMetersPerSRUnit: c2, offsetScaleFactor: u3, spatialReference: g, gridMetersPerStride: f2, pixelsPerStride: m2 } = this;
    if (!(i2 && a2 && c2 && s2 && g && u3 && f2 && m2)) return r4;
    if (!i2.dynamicScaling && m2 < t) return r4;
    if (!U(t2.spatialReference, g)) return r4;
    const S = O(t2, g), w3 = f(S.x, S.y, S.z), x = P2(w3, -o, s2, -n), C = f2 / c2 * u3, U2 = j2(x, C, s2), { shouldSnapX: b2, shouldSnapY: L } = R(U2, x, e, a2, c2);
    if (!b2 && !L) return [];
    const z = f((b2 ? U2 : x)[0], (L ? U2 : x)[1]), E = P2(z, o, s2, n), F = P2(U2, o, s2, n);
    if (L) {
      const t3 = M(U2, x, C, "y"), e2 = P2(t3, o, s2, n);
      r4.push(new r3({ lineStart: F, lineEnd: e2, targetPoint: E, isDraped: false }));
    }
    if (b2) {
      const t3 = M(U2, x, C, "x"), e2 = P2(t3, o, s2, n);
      r4.push(new r3({ lineStart: F, lineEnd: e2, targetPoint: E, isDraped: false }));
    }
    return b2 && L && r4.push(new r2(E, r4[0], r4[1], false)), r4;
  }
};
r([m({ constructOnly: true })], w2.prototype, "view", void 0), r([m()], w2.prototype, "options", void 0), r([m()], w2.prototype, "grid", null), r([m()], w2.prototype, "effectiveViewRotation", null), r([m()], w2.prototype, "gridRotation", null), r([m()], w2.prototype, "gridCenter", null), r([m()], w2.prototype, "offsetScaleFactor", null), r([m()], w2.prototype, "spatialReference", null), r([m()], w2.prototype, "gridMetersPerStride", null), r([m()], w2.prototype, "viewMetersPerPixel", null), r([m()], w2.prototype, "viewMetersPerSRUnit", null), r([m()], w2.prototype, "pixelsPerStride", null), r([m()], w2.prototype, "updating", null), w2 = r([a("esri.views.interactive.snapping.GridSnappingEngine")], w2);
var P2 = (t2, e, r4, i2) => {
  const n = c(t2[0], t2[1], t2[2]);
  return w(n, w(n, n, r4, e), r4, i2);
};
var j2 = (t2, e, r4) => {
  const i2 = (t2[0] - r4[0]) / e, n = (t2[1] - r4[1]) / e, o = Math.trunc(i2), s2 = Math.trunc(n), a2 = Math.round(i2 % 1), p = Math.round(n % 1), l2 = r4[0] + (o + a2) * e, c2 = r4[1] + (s2 + p) * e;
  return f(l2, c2);
};
var R = (t2, e, r4, i2, n) => {
  if (i2 <= 0) return { shouldSnapX: false, shouldSnapY: false };
  const o = (t2[0] - e[0]) / i2, s2 = (t2[1] - e[1]) / i2;
  return { shouldSnapX: Math.abs(o * n) < r4, shouldSnapY: Math.abs(s2 * n) < r4 };
};
var M = (t2, e, r4, i2) => {
  if ("y" === i2) {
    const i3 = e[0] > t2[0] ? 1 : -1;
    return f(t2[0] + r4 * i3, t2[1]);
  }
  const n = e[1] > t2[1] ? 1 : -1;
  return f(t2[0], t2[1] + r4 * n);
};
export {
  w2 as GridSnappingEngine
};
//# sourceMappingURL=GridSnappingEngine-5WVXGEAV.js.map
